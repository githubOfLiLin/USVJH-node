(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[0],{

/***/ "./image/images1/anchor1.png":
/*!***********************************!*\
  !*** ./image/images1/anchor1.png ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"./images/anchor1.png\";\n\n//# sourceURL=webpack:///./image/images1/anchor1.png?");

/***/ }),

/***/ "./mainmap/toolbar_event.js":
/*!**********************************!*\
  !*** ./mainmap/toolbar_event.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/*\r\n顶部工具栏各个工具按钮所实现的功能事件\r\n*/\n//const $=require(\"../common/jquery-3.3.1.min.js\");\n//全局变量\nvar screenshot;\nvar mapCanvas; //画图容器\nvar ctx; //画图容器上下文\nvar map;\nvar center; //中间map+右侧菜单栏\nvar offTop;\n//各个工具栏按钮\nvar barEBL;\nvar barMeasure;\nvar barAnchor;\nvar barCleanAnchor;\n//各个工具按钮的标志量\nvar boolToolBar = {\n  EBL: false,\n  measure: false,\n  anchor: false\n};\n//画电子方位线所需的参数，半径以及圆心的经纬度点\nvar paramOfEBL = {\n  centerPosL: { x: 0, y: 0 },\n  radiusPosL: { x: 0, y: 0 },\n  draw: false\n};\n//画测距线所需参数\nvar paramMeasure = {\n  PosLArray: [] //数组中存储一系列测距点，每个点由坐标x,y表示\n};\n//画锚点所需参数\nvar paramAnchor = {\n  PosLArray: [], //数\"组中存储一系列测距点，每个点由坐标x,y表示\n  img: {}\n  //添加航线所需参数\n\n};var baseNum = Math.pow(10, 8); //经纬度转地理坐标\n\n//用户名\nvar username = \"\";\nvar userCon; //用户名所在的span\n/*\r\n截屏功能\r\n*/\nfunction captureScreen() {\n  console.log(\"capturescreen\");\n  // API_CutMapViewToImg(true, true, \"capture\",{w:200,h:200},null);//API有问题，截屏后的图片不能显示\n}\n/*\r\n电子方位线\r\n*/\nfunction getElecBearLine() {\n  var centerPos = { x: 0, y: 0 }; //圆心\n  //使paramOfEBL.draw为false，\n  //每次就算没有点击鼠标右键取消绘制，在每次画新的电子方位线时也要清除一下画布\n  paramOfEBL.draw = false;\n  if (!boolToolBar.EBL) {\n    map.onmousedown = function (ev) {\n      API_ClearCurMouseMove(); //清除原有的地图的鼠标移动事件\n      centerPos.x = ev.pageX;\n      centerPos.y = ev.pageY - offTop;\n      var posL = API_GetLonLatPoByScrnPo(centerPos.x, centerPos.y, null); //屏幕坐标转换成经纬度坐标\n      paramOfEBL.centerPosL.x = posL.x;\n      paramOfEBL.centerPosL.y = posL.y;\n      paramOfEBL.draw = true;\n      return false;\n    };\n    var mouseMove = function mouseMove() {\n      var ev = arguments[0];\n      var radiusX = ev.pageX;\n      var radiusY = ev.pageY - offTop;\n      var radiusPos = { x: radiusX, y: radiusY };\n      var posL = API_GetLonLatPoByScrnPo(radiusPos.x, radiusPos.y, null); //屏幕坐标转换成经纬度坐标;\n      paramOfEBL.radiusPosL.x = posL.x;\n      paramOfEBL.radiusPosL.y = posL.y;\n      return false;\n    };\n    map.onmousemove = throttle(mouseMove, 200);\n    map.onmouseup = function () {\n      map.onmousedown = null;\n      map.onmousemove = null;\n      map.onmouseup = null;\n    };\n    boolToolBar.EBL = true;\n    barEBL.title = \"取消电子方位线\";\n  } else {\n    boolToolBar.EBL = false;\n    barEBL.title = \"电子方位线\";\n  }\n}\n//测距和角度\nfunction getDistAndAng() {\n  if (!boolToolBar.measure) {\n    API_ClearCurMouseMove(); //清除原有的地图的鼠标移动事件\n    paramMeasure.PosLArray = [];\n    //类才有原型，paramMeasure.PosLArray只是一个数组实例，没有原型，Array才有原型\n    map.onclick = function (ev) {\n      var posS = { x: 0, y: 0 };\n      posS.x = ev.pageX;\n      posS.y = ev.pageY - offTop;\n      var posL = API_GetLonLatPoByScrnPo(posS.x, posS.y, null);\n      paramMeasure.PosLArray.push(posL);\n    };\n    boolToolBar.measure = true;\n    barMeasure.title = \"取消测距\";\n  } else {\n    paramMeasure.PosLArray = [];\n    boolToolBar.measure = false;\n    barMeasure.title = \"测距\";\n  }\n}\n\n/*\r\n添加锚点\r\n以canvas贴image的方式标志锚点\r\n*/\nfunction addAnchor() {\n  API_ClearCurMouseMove(); //清除原有的地图的鼠标移动事件\n  boolToolBar.anchor = true;\n  //paramAnchor.PosLArray = [];\n  //类才有原型，paramMeasure.PosLArray只是一个数组实例，没有原型，Array才有原型\n  map.onclick = function (ev) {\n    var posS = { x: 0, y: 0 };\n    var imageS = { x: 0, y: 0 };\n    posS.x = ev.pageX;\n    posS.y = ev.pageY - offTop;\n    imageS.x = posS.x - 10;\n    imageS.y = posS.y - 10;\n    var posL = API_GetLonLatPoByScrnPo(posS.x, posS.y, null);\n    paramAnchor.PosLArray.push(posL);\n  };\n}\n//清除锚点\nfunction cleanAchor() {\n  paramAnchor.PosLArray = [];\n  boolToolBar.anchor = false;\n  console.log(\"clear\");\n  //发送get请求\n  var xhr = new XMLHttpRequest();\n  xhr.onreadystatechange = function () {\n    console.log(\"路径正确\");\n    if (xhr.readyState == 4 && xhr.status == 200) {\n      //获得来自服务器的响应\n      var data = xhr.responseText;\n      // data=JSON.parse(data);\n      console.log(data);\n    }\n  };\n  xhr.open(\"get\", \"/dataFile/anchor.json?delete=all\", true); //绝对路径，相对于服务器根目录\n  xhr.send(null);\n}\n\n/*\r\n*添加航线\r\n*/\nfunction addRoute() {}\n\n//更新Canvas\nfunction refreshCanvas() {\n  setInterval(function () {\n    drawCanvas();\n  }, 200);\n}\n\n/*\r\ncanvas画图，根据点击的工具按钮画不同的图，要有标志量\r\n*/\nfunction drawCanvas() {\n  ctx.clearRect(0, 0, mapCanvas.width, mapCanvas.height);\n  //电子方位线\n  if (paramOfEBL.draw) {\n    var centerPosL = paramOfEBL.centerPosL;\n    var radiusPosL = paramOfEBL.radiusPosL;\n    var centerPosS = API_GetScrnPoByLonLatPo(centerPosL.x, centerPosL.y, null);\n    var radiusPosS = API_GetScrnPoByLonLatPo(radiusPosL.x, radiusPosL.y, null);\n    var offX = radiusPosS.x - centerPosS.x;\n    var offY = radiusPosS.y - centerPosS.y;\n    var radius = Math.sqrt(offX * offX + offY * offY);\n    ctx.beginPath(); //开始路径\n    ctx.strokeStyle = \"#f00\"; //边框颜色\n    ctx.arc(centerPosS.x, centerPosS.y, radius, 0, Math.PI * 2); //参数依次为圆心坐标x,y，半径，开始结束角，绘制方向顺时针\n    ctx.stroke();\n    ctx.closePath(); //关闭路径\n    //画直线\n    ctx.beginPath(); //开始路径\n    ctx.strokeStyle = \"#00f\"; //边框颜色\n    ctx.moveTo(centerPosS.x, centerPosS.y);\n    ctx.lineTo(radiusPosS.x, radiusPosS.y);\n    ctx.stroke();\n    ctx.closePath(); //关闭路径\n    //绘制两点之间的角度和距离\n    var dist = API_GetDistBetwTwoPoint(centerPosL.x * baseNum, centerPosL.y * baseNum, radiusPosL.x * baseNum, radiusPosL.y * baseNum);\n    var angle = API_GetDegreesBetwTwoPoint(centerPosL.x * baseNum, centerPosL.y * baseNum, radiusPosL.x * baseNum, radiusPosL.y * baseNum);\n    dist = dist.toFixed(2).toString();\n    angle = angle.toFixed(2).toString();\n    ctx.fillStyle = \"#f00\";\n    ctx.font = \"16px Arial\";\n    ctx.fillText(\" \" + dist + \"km \" + angle + \"度\", radiusPosS.x, radiusPosS.y);\n  }\n  //测距\n  if (boolToolBar.measure) {\n    if (paramMeasure.PosLArray.length > 0) {\n      var prePosL = paramMeasure.PosLArray[0];\n      var prePosS = API_GetScrnPoByLonLatPo(prePosL.x, prePosL.y, null);\n      ctx.beginPath();\n      ctx.fillStyle = \"#00f\";\n      ctx.arc(prePosS.x, prePosS.y, 2, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.closePath();\n    }\n\n    for (var i = 1, len = paramMeasure.PosLArray.length; i < len; i++) {\n      var _prePosL = paramMeasure.PosLArray[i - 1];\n      var nextPosL = paramMeasure.PosLArray[i];\n      var _prePosS = API_GetScrnPoByLonLatPo(_prePosL.x, _prePosL.y, null);\n      var nextPosS = API_GetScrnPoByLonLatPo(nextPosL.x, nextPosL.y, null);\n      //画线\n      ctx.beginPath();\n      ctx.strokeStyle = \"#f00\";\n      ctx.moveTo(_prePosS.x, _prePosS.y);\n      ctx.lineTo(nextPosS.x, nextPosS.y);\n      ctx.stroke();\n      ctx.closePath();\n      //画点，以画圆的方式实现\n      ctx.beginPath();\n      ctx.fillStyle = \"#00f\";\n      ctx.arc(_prePosS.x, _prePosS.y, 2, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.closePath();\n      if (i == len - 1) {\n        ctx.beginPath();\n        ctx.fillStyle = \"#00f\";\n        ctx.arc(nextPosS.x, nextPosS.y, 2, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.closePath();\n      }\n      //显示两点之间的距离和角度\n      var _dist = API_GetDistBetwTwoPoint(_prePosL.x * baseNum, _prePosL.y * baseNum, nextPosL.x * baseNum, nextPosL.y * baseNum);\n      var _angle = API_GetDegreesBetwTwoPoint(_prePosL.x * baseNum, _prePosL.y * baseNum, nextPosL.x * baseNum, nextPosL.y * baseNum);\n      _dist = _dist.toFixed(2).toString();\n      _angle = _angle.toFixed(2).toString();\n      ctx.font = \"16px Arial\";\n      ctx.fillStyle = \"#f00\";\n      ctx.fillText(_dist + \"km \" + _angle + \"度\", nextPosS.x, nextPosS.y);\n    }\n  }\n  //锚点\n  if (paramAnchor.PosLArray.length > 0) {\n    if (paramAnchor.PosLArray.length > 0) {\n      var _prePosL2 = paramAnchor.PosLArray[0];\n      var _prePosS2 = API_GetScrnPoByLonLatPo(_prePosL2.x, _prePosL2.y, null);\n      ctx.drawImage(paramAnchor.img, _prePosS2.x - 10, _prePosS2.y - 10, 20, 20);\n    }\n    for (var _i = 1, _len = paramAnchor.PosLArray.length; _i < _len; _i++) {\n      var _prePosL3 = paramAnchor.PosLArray[_i - 1];\n      var _nextPosL = paramAnchor.PosLArray[_i];\n      var _prePosS3 = API_GetScrnPoByLonLatPo(_prePosL3.x, _prePosL3.y, null);\n      var _nextPosS = API_GetScrnPoByLonLatPo(_nextPosL.x, _nextPosL.y, null);\n      //画线 画虚线\n      ctx.beginPath();\n      ctx.strokeStyle = \"#555\";\n      ctx.moveTo(_prePosS3.x, _prePosS3.y);\n      ctx.lineTo(_nextPosS.x, _nextPosS.y);\n      ctx.stroke();\n      ctx.closePath();\n      //画图标，以贴图的方式实现 \n      ctx.drawImage(paramAnchor.img, _prePosS3.x - 10, _prePosS3.y - 10, 20, 20);\n      if (_i == _len - 1) {\n        ctx.drawImage(paramAnchor.img, _nextPosS.x - 10, _nextPosS.y - 10, 20, 20);\n      }\n    }\n  }\n}\n\n//函数节流，性能问题\nfunction throttle(func, delay) {\n  //结合了时间戳和定时器，使得在事件第一次触发时就立即执行\n  //而事件最后一次触发后也会再执行一次\n  var timer = null;\n  var startTime = Date.now();\n  return function () {\n    var curTime = Date.now();\n    var remaining = delay - (curTime - startTime);\n\n    var context = this;\n    var args = arguments;\n    //throttle函数return的函数才是事件本身所绑定的函数，\n    //所以要获得的也是这个函数的参数，从而传递给真正要执行的事件函数\n    //而不是throttle函数的参数\n    clearTimeout(timer); //定时器未触发之前清除定时器事件，但是定时器并不是null\n    if (remaining <= 0) {\n      func.apply(context, args);\n      startTime = Date.now();\n    } else {\n      //remaining是在不断减少的，所以尽管timer每次触发都会清空上一次的timer\n      //但总有一次是在还来不及清空时，就触发了的，所以，要么是时间戳触发，要么是定时器触发\n      timer = setTimeout(function () {\n        func.apply(context, args);\n      }, remaining);\n    }\n  };\n}\n\nfunction wOnload2() {\n  //DOM\n  screenshot = document.getElementById(\"screenshot\");\n  map = document.getElementById(\"map\");\n  center = document.querySelector(\".center\");\n  mapCanvas = document.getElementById(\"map_canvas\");\n  ctx = mapCanvas.getContext(\"2d\");\n  barEBL = document.getElementById(\"elec_bearline\");\n  barMeasure = document.getElementById(\"measure\");\n  barAnchor = document.getElementById(\"anchor\");\n  barCleanAnchor = document.getElementById(\"clean_anchor\");\n  userCon = document.querySelector(\".user\");\n  offTop = center.offsetTop;\n  // paramAnchor.img=new Image();\n  // paramAnchor.img.src=\"D:/Work-web/HAITU/USVJH/image/images1/anchor1.png\";\n  paramAnchor.img = new Image();\n  paramAnchor.img.src = __webpack_require__(/*! ../image/images1/anchor1.png */ \"./image/images1/anchor1.png\");\n  //动态引入图片资源，则需要使用require命令，将该图片打包到静态资源中，不然会出现找不到正确路径\n  /*\r\n  事件\r\n  */\n\n  //截屏\n  screenshot.onclick = function () {\n    captureScreen();\n  };\n  //电子方位线功能\n  barEBL.onclick = function () {\n    getElecBearLine();\n  };\n  //测距\n  barMeasure.onclick = function () {\n    getDistAndAng();\n  };\n  //添加锚点\n  barAnchor.onclick = function () {\n    addAnchor();\n  };\n\n  barCleanAnchor.onclick = function () {\n    cleanAchor();\n  };\n  //map鼠标右键，取消画图\n  map.oncontextmenu = function (ev) {\n    ev.preventDefault();\n    if (boolToolBar.measure) {\n      map.onclick = null;\n    }\n    if (boolToolBar.anchor) {\n      map.onclick = null;\n      //发送post请求\n      var _xhr = new XMLHttpRequest();\n      _xhr.onreadystatechange = function () {\n        if (_xhr.readyState == 4 && _xhr.status == 200) {\n          //获得来自服务器的响应\n          var data = _xhr.responseText;\n          // data=JSON.parse(data);\n          console.log(data);\n        }\n      };\n      _xhr.open(\"post\", \"/dataFile/anchor.json\", true); //绝对路径，相对于服务器根目录\n      _xhr.setRequestHeader(\"Content-Type\", \"application/json\"); // 可以定义请求头带给后端\n      var strdata = JSON.stringify(paramAnchor.PosLArray);\n      _xhr.send(strdata);\n    }\n    return false;\n  };\n  //将保存在服务端的需要画图的数据请求过来\n  //发送get请求\n  var xhr = new XMLHttpRequest();\n  xhr.onreadystatechange = function () {\n    if (xhr.readyState == 4 && xhr.status == 200) {\n      //获得来自服务器的响应\n      var data = xhr.responseText;\n      console.log(typeof data === \"undefined\" ? \"undefined\" : _typeof(data));\n      paramAnchor.PosLArray = JSON.parse(data);\n    }\n  };\n  xhr.open(\"get\", \"/dataFile/anchor.json?add=all\", true); //绝对路径，相对于服务器根目录\n  xhr.setRequestHeader(\"Accept\", \"application/json\");\n  xhr.send(null);\n\n  //登录之后，从cookie获取用户名，并将用户名显示在右侧工具栏上\n  var xhrUser = new XMLHttpRequest();\n  xhrUser.onreadystatechange = function () {\n    if (xhrUser.readyState == 4 && xhrUser.status == 200) {\n      //获得来自服务器的响应\n      var data = xhrUser.responseText;\n      console.log(typeof data === \"undefined\" ? \"undefined\" : _typeof(data));\n      username = data;\n      userCon.innerText = data;\n    }\n  };\n  xhrUser.open(\"get\", \"/mainmap\", true); //绝对路径，相对于服务器根目录\n  xhrUser.setRequestHeader(\"Accept\", \"text/plain\");\n  xhrUser.send(null);\n  /*\r\n  更新canvas画图\r\n  */\n  refreshCanvas();\n}\nwOnload2();\n\n//# sourceURL=webpack:///./mainmap/toolbar_event.js?");

/***/ })

}]);